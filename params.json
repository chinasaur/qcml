{"name":"QCML","tagline":"Quadratic cone modeling language","body":"Quadratic Cone Modeling Language (QCML)\r\n=======================================\r\n\r\n**This repository is currently a work in progress\r\nIf you wish to use this in your project, please contact\r\n[us](mailto:echu508@stanford.edu).**\r\n\r\nThis project is a modular convex optimization framework for solving\r\n*second-order cone* optimization problems (SOCP). It separates the parsing\r\nand canonicalization phase from the code generation and solve phase. This\r\nallows the use of a unified (domain-specific) language in the front end to\r\ntarget different use cases.\r\n\r\nFor instance, a simple portfolio optimization problem can be specified as a\r\nPython string as follows:\r\n\r\n    \"\"\"\r\n    dimensions m n\r\n\r\n    variable x(n)\r\n    parameter mu(n)\r\n    parameter gamma positive\r\n    parameter F(n,m)\r\n    parameter D(n,n)\r\n    maximize (mu'*x - gamma*(square(norm(F'*x)) + square(norm(D*x))))\r\n        sum(x) == 1\r\n        x >= 0\r\n    \"\"\"\r\n\r\nOur tool parses the problem and rewrites it, after which it can generate\r\nPython code of external source code. The basic workflow is as follows\r\n(assuming `s` stores a problem specification).\r\n\r\n    p.parse(s)\r\n    p.canonicalize()\r\n    p.set_dims({'m': m, 'n': n})\r\n    p.codegen(\"cvxopt\")\r\n    solution = p.solver({'gamma':1,'F':F,'D':D})\r\n\r\nThe third line sets the dimensions of the problem and the last line calls\r\nthe (Python) solver generated in the codegen step. This\r\nsolver requires that the user specify the parameters in their\r\noptimization model. For rapid prototyping, we provide the convenience\r\nfunction:\r\n\r\n    solution = p.solve(locals())\r\n\r\nThis functions wraps the last four steps above into a single call and\r\nassumes that all parameters and dimensions are defined in the local\r\nnamespace.\r\n\r\nPrerequisites\r\n=============\r\nFor the most basic usage, this project requires:\r\n\r\n* Python 2.7.2+ (no Python 3 support yet)\r\n* [CVXOPT](http://abel.ee.ucla.edu/cvxopt/)\r\n\r\nFor (some) unit testing, we use [Nose](http://nose.readthedocs.org).\r\n\r\nDepending on the type of code you generate, you may also need:\r\n\r\n* Matlab\r\n* [CVX](http://cvxr.com)\r\n* [PDOS](http://github.com/cvxgrp/pdos)\r\n* [ECOS](http://github.com/ifa-ethz/ecos)\r\n\r\nPDOS is an experimental first-order solver, and we recommend CVXOPT or ECOS\r\nover it.\r\n\r\nInstallation\r\n============\r\nInstallation should be as easy as\r\n\r\n    cd src\r\n    python setup.py install\r\n\r\nAfter installation, if you have [Nose](http://nose.readthedocs.org) installed,\r\nthen typing\r\n\r\n    nosetests scoop\r\n\r\nshould run the simple unit tests. These tests are not exhaustive at the\r\nmoment.\r\n\r\nThe only working sample scripts are `qcml_example.py` and `main.py`.\r\nThe others refer to an older implementation. The `main.py` script takes\r\ncommand line arguments and emits Matlab code used to call ECOS.\r\n\r\n\r\nFeatures\r\n========\r\n\r\nParsing and canonicalization\r\n----------------------------\r\nThe parser/canonicalizer canoncializes SOCP-representable *convex*\r\noptimization problems into standard form:\r\n\r\n    minimize c'*x\r\n    subject to\r\n      G*x + s == h\r\n      A*x == b\r\n      s in Q\r\n\r\nwhere `Q` is a product cone of second-order cones (i.e., `Q = { (t,y) | ||y||\r\n<= t }`), and `x`, `s` are the optimization variables. The\r\nparser/canonicalizer guarantees that all problems will adhere to the\r\ndisciplined convex programming (DCP) ruleset and that the problem has the form\r\n\r\n    minimize aff\r\n    subject to\r\n      aff == 0\r\n      norm(aff) <= aff\r\n\r\nwhere `aff` is any affine expression. This can also be a maximization or\r\nfeasibility problem. If a problem is entered directly in this form, the\r\nparser/canonicalizer will not modify it; in other words, the\r\nparser/canonicalizer is *idempotent* with respect to SOCPs.\r\n\r\nGeneration and solve\r\n--------------------\r\nThe generator/solver can be used in prototyping or deployment mode. In\r\nprototyping mode (or solve mode), a *function* is generated which, when\r\nsupplied with the problem parameters, will call an interior-point solver to\r\nsolve the problem. In deployment mode (or code generation mode), *source\r\ncode* (in a target language) is generated which solves a particular problem\r\ninstance with fixed dimensions.\r\n\r\nIn prototyping mode, the problem data may change with each invocation of\r\nthe generated function. If problem dimensions change, you must set the\r\ndimensions of the QCML object and codegen the Python function again.\r\nIn deployment mode, the problem dimensions are fixed,\r\nbut problem data is allowed to change.\r\n\r\nThe valid choice of solvers are:\r\n\r\n* `\"cvx\"` -- emits Matlab source code that calls CVX\r\n* `\"cvxopt\"` -- emits Python source code that calls CVXOPT\r\n* `\"ecos\"` -- emits Python source code that calls ECOS\r\n* `\"matlab\"` -- emits Matlab source code that calls ECOS\r\n* `\"PDOS\"` -- emits Python source code that calls PDOS\r\n\r\nWhen these solvers are supplied as arguments to the code generator,\r\nit produces code of the appropriate language (Python or Matlab).\r\nIf it generates Python code, `exec` is called to create the function\r\nbytecode dynamically, allowing you to call the solver.\r\n\r\nUse as embedded language\r\n------------------------\r\nAlthough QCML's original intent was to be used to parse files with problems\r\nspecified in QCML, its Python API has been exposed for use in Python. It\r\noperates similarly to a safe `eval` in Python. Problems can be passed as\r\nstrings to the API and prototyping functions can be used to evaluate the\r\nmodel before asking QCML to generate a solver in a more efficient langauge,\r\nsuch as in C or CUDA.\r\n\r\nExample\r\n=======\r\nAs an example, consider the Lasso problem,\r\n\r\n    # this entire line is a comment!\r\n    dimensions m n\r\n    variable x(n)\r\n    parameter A(m,n)\r\n    parameter lambda positive\r\n\r\n    minimize sum(square(A*x - 4)) + lambda*norm(x)\r\n\r\nNote that dimenions are named, but abstract (they do not refer to any\r\nnumbrs). Similarly, variables and parameters are abstract, their shape is\r\ndenoted only by references to named dimensions. Although matrix variable\r\n*declarations* are possible, QCML's behavior is undefined (and may possibly\r\nfail). Matrix variables (along with `for` loops, concatenation, and slicing)\r\nare planned for a future release.\r\n<!--\r\nSome currently available keywords are:\r\n\r\n* `dimension`, `dimensions`\r\n* `variable`, `variables`\r\n* `parameter`, `parameters`\r\n* `positive`, `nonnegative`\r\n* `negative`, `nonpositive`\r\n* `minimize`\r\n* `maximize`\r\n-->\r\n\r\nQCML canonicalizes this problem to an SOCP.\r\n\r\nInside Python, the code might look like\r\n\r\n    from scoop import QCML\r\n    if __name__ == '__main__':\r\n        p = QCML()\r\n\r\n        p.parse(\"\"\"\r\n          # this entire line is a comment!\r\n          dimension n\r\n          dimension m\r\n          variable x(n)\r\n          parameter A(m,n)\r\n          parameter lambda positive\r\n\r\n          minimize sum(square(A*x - 4)) + lambda*norm(x)\r\n        \"\"\")\r\n\r\n        p.canonicalize()\r\n        p.set_dims({'m':m, 'n':n})\r\n        p.prettyprint()\r\n\r\nThsis will canonicalize the problem and build an internal problem parse\r\ntree inside Python. Once the problem has been canonicalized, the user can\r\ndecide to either generate a function to prototype problems or generate source\r\ncode. For instance, the following three lines will create a solver function\r\n`f` and call the solver, with the parameter arguments supplied.\r\n\r\n    p.codegen(\"cvxopt\")  # this creates a solver in Python calling CVXOPT\r\n    f = p.solver\r\n    f({'A': A, 'lambda':0.01})\r\n\r\nNote that this is not possible with one of the Matlab code generators.\r\n\r\n<!-- Parameter dimensions and sparsity patterns are assumed to be unknown *until* the generated function is run. That is, after the code has been parsed and a function generated, the user will not be able to know that parameters have the wrong dimensions or storage format until attempting to run the function. This is by design.\r\n\r\nOnce the user feels that the model is sufficient and wishes to scale to a problem with more data, the following line might conceivably generate source code to solve a problem instance (with fixed dimensions and sparsity pattern).\r\n\r\n    p.generateC(x = 1e6, A = sparsity_pattern)\r\n\r\nThe argument corresponding to the variable name gives the length of the vector, and an exemplar for the sparsity pattern of parameters may be provided in lieu of its dimensions.\r\n\r\nNote that SCOOP is stateful, so one could use Python as a templating language and declare multiple variables\r\n\r\n    for i in range(n):\r\n      p.run(\"variable x%d scalar\" % i) -->\r\n\r\n\r\n<!-- Scientific computing mode\r\n=========================\r\nParse tree only produces a list of linear functions. These are repeatedly evaluated in the solver. -->\r\n\r\nOperators and atoms\r\n===================\r\nQCML provides a set of linear operators and atoms for use with modeling.\r\nSince an SOCP only consists of affine functions and second-order cone\r\ninequalities, we only provide linear operators and operators for constructing\r\nsecond-order cones. All other atoms are implemented as *macros*. Whenever the\r\nparser encounters an atom, it simply expands its definition.\r\n\r\nOperators\r\n---------\r\nThe standard linear operators are:\r\n\r\n* infix operators\r\n  * `+`\r\n  * `-`\r\n  * `*`, lhs *must* be a parameter\r\n  * `\\`, rhs and lhs *must* be numeric constants\r\n* prefix operators\r\n  * `-`, unary minus / negate\r\n* vector operators (map vectors to scalars)\r\n  * `sum(x)`\r\n  * `sum(x,y,..)`, defined as `x + y + ...`\r\n\r\nThe operators used for constructing second-order cones are:\r\n\r\n* scalar operators (map scalars to scalars)\r\n  * `abs(x)`\r\n* vector operators (map vectors to scalars)\r\n  * `norm(x)`\r\n  * `norm2(x)`, equivalent to `norm(x)`\r\n\r\nAtoms\r\n-----\r\nThe atoms we provide are:\r\n\r\n* scalar atoms (map scalars to scalars)\r\n  * `pos(x)`, defined as `max(x, 0)`\r\n  * `neg(x)`, defined as `max(-x, 0)`\r\n  * `square(x)`\r\n  * `inv_pos(x)`\r\n  * `geo_mean(x,y)`\r\n  * `sqrt(x)`\r\n* vector atoms (map vectors to scalars)\r\n  * `max(x)`, the max elem of `x`\r\n  * `max(x,y,..)`, the max vector consisting of max elements across rows\r\n  * `min(x)`, the min elem of `x`,\r\n  * `min(x,y,..)`, the min vector consisting of min elements across rows\r\n  * `quad_over_lin(x,y)`, if `y` is a vector, returns element-wise operator\r\n  * `norm1(x)`, defined as `sum(abs(x))`\r\n  * `norm1(x,y,..)`, defined as `abs(x) + abs(y) + ...`\r\n  * `norm_inf(x)`, defined as `max(abs(x))`\r\n  * `norm_inf(x,y,...)`, defined as `max(abs(x),abs(y),...)`\r\n\r\nRoadmap\r\n=======\r\nIn no particular order, the future of this project...\r\n\r\n* C code generation for ECOS\r\n* CUDA and GPU support for large-scale solvers\r\n* test cases\r\n* example suite\r\n* user guide\r\n* a solver based on scientific computing (just walks parse trees)\r\n\r\nSupport\r\n=======\r\nThis project is supported in large part by an XDATA grant, supported by the\r\nAir Force Research Laboratory grant FA8750-12-2-0306.\r\n\r\n\r\n<!-- Syntax\r\n------\r\nThe input language follows a syntax similar to CVXGEN. If you are familiar\r\nwith imperative languages, then it shouldn't be too unfamiliar. Dimensions,\r\nparameters, and variables (also called symbols) must be declared before use.\r\nYou cannot forward-declare these. However, you can declare them in whichever\r\norder as long as you do not refer to undefined symbols: for instance, you\r\ncould write\r\n\r\n    parameter b\r\n    dimension n = 10\r\n    variable x(n)\r\n\r\nAs a consequence, the problem declaration must appear last.\r\n\r\n### Concatenation ###\r\nOnly *vertical* concatenation is allowed. This is accomplished using Matlab\r\nsyntax:\r\n\r\n    [x; y]\r\n\r\nwill concatenate two vector expressions vertically. It will not keep track of\r\nindividual properties. Instead, if a positive and negative (or convex and\r\nconcave) expression are concatenated, the result is a vector of unknown sign\r\n(or curvature).\r\n\r\n### Vector transpose ###\r\nAt the moment, we don't support vector transposes. For linear objectives such\r\nas `c'*x`, the parameter has to be transposed externally and stated as\r\n`parameter ct(1,n)` instead of `parameter c(n)`.\r\n\r\nSample problem\r\n--------------\r\nAs an example, consider the following problem:\r\n\r\n    dimension n = 5\r\n    dimension m = 10\r\n\r\n    parameter A(m,n)\r\n    parameter b(m)\r\n    parameter lambda positive\r\n    variable x(n)\r\n\r\n    minimize square(norm(A*x - b)) + lambda*norm1(x)\r\n    subject to\r\n      x >= 0\r\n\r\nSample output\r\n-------------\r\nAssuming the example text is saved to a file called `example.prob`, running `./efe --ecos example.prob` will produce:\r\n\r\n    c_ = sparse(53,1);\r\n    c_(53) = 1;\r\n    b_ = sparse(41,1);\r\n    b_(2:2) = -0.5*ones(1, 1);\r\n    b_(3:3) = -0.5*ones(1, 1);\r\n    b_(24:33) = b;\r\n    A_ = sparse(41, 53);\r\n    A_(1:1, 29:29) = 1*ones(1, 1); A_(1:1, 30:30) = 1*speye(1, 1); A_(1:1, 53:53) = -1*speye(1, 1);\r\n    A_(2:2, 29:29) = 0.5*speye(1, 1); A_(2:2, 1:1) = -1*speye(1, 1);\r\n    A_(3:3, 29:29) = -0.5*speye(1, 1); A_(3:3, 2:2) = -1*speye(1, 1);\r\n    A_(4:13, 31:40) = 1*speye(10, 10); A_(4:13, 41:50) = -1*speye(10, 10); A_(4:13, 4:13) = -1*speye(10, 10);\r\n    A_(14:23, 19:23) = A; A_(14:23, 31:40) = -1*speye(10, 10);\r\n    A_(24:33, 41:50) = 1.0*speye(10, 10);\r\n    A_(34:34, 51:51) = lambda*speye(1, 1); A_(34:34, 30:30) = -1*speye(1, 1);\r\n    A_(35:35, 14:18) = 1*ones(1, 5); A_(35:35, 51:51) = -1*ones(1, 1);\r\n    A_(36:40, 19:23) = 1*speye(5, 5); A_(36:40, 24:28) = -1*speye(5, 5); A_(36:40, 52:52) = -1*ones(5, 1);\r\n    A_(41:41, 52:52) = 1.0*speye(1, 1);\r\n    G_ = sparse(29, 53);\r\n    G_(1:1:5, 24:28) = -speye(5, 5);\r\n    G_(6:2:15, 14:18) = -speye(5, 5);\r\n    G_(7:2:16, 19:23) = -speye(5, 5);\r\n    G_(16:1:16, 1:1) = -speye(1, 1);\r\n    G_(17:1:17, 2:2) = -speye(1, 1);\r\n    G_(18:1:18, 3:3) = -speye(1, 1);\r\n    G_(19:1:19, 3:3) = -speye(1, 1);\r\n    G_(20:1:29, 4:13) = -speye(10, 10);\r\n    h_ = zeros(29, 1);\r\n    dims.q = [2,2,2,2,2,3,11];\r\n    dims.l = 5;\r\n\r\n    [x_codegen, y_, info_] = ecos(full(c_), G_, h_, dims, A_, full(b_));\r\n\r\n    t1z0 = x_codegen(1:1);\r\n    t1z1 = x_codegen(2:2);\r\n    t2 = x_codegen(3:3);\r\n    t3 = x_codegen(4:13);\r\n    t7z0 = x_codegen(14:18);\r\n    x = x_codegen(19:23);\r\n    xGTt8 = x_codegen(24:28);\r\n    t1 = x_codegen(29:29);\r\n    t6 = x_codegen(30:30);\r\n    t4 = x_codegen(31:40);\r\n    t5 = x_codegen(41:50);\r\n    t7 = x_codegen(51:51);\r\n    t8 = x_codegen(52:52);\r\n    t0 = x_codegen(53:53);\r\n    ecos_optval = 1*info_.pcost;\r\n\r\nThis file can be run inside Matlab and assumes that the parameters named `A`,\r\n`b`, and `lambda` exist in the namespace. It doesn't check if `lambda` is\r\nactually positive. -->\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}