<h1>ECOS front end (EFE)</h1>

<p>This project contains a front end for the <em>embedded conic solver</em> (<code>ECOS</code>) to
solve <em>second-order cone problems</em> (SOCP). In <code>ECOS</code>, a second-order cone
problem is</p>

<pre><code>minimize c'*x
subject to
  G*x + s == h
  A*x == b
  s In K
</code></pre>

<p>where <code>K</code> is a product cone of linear and second-order cones..</p>

<p>The front end provides an input language (and accompanying syntax) used to
enter problems in text files. The front end is called with the text file
supplied as argument to "compile" the code in to four different targets:</p>

<ul>
<li><p><code>CVX</code> -- This converts the problem in to an SOCP (with new variables) and
outputs a CVX problem with only equality constraints and cone constraints.
The equality constraints are given literally in terms of the variable names
(i.e., they are not stuffed in to matrices).</p></li>
<li><p><code>CVX</code> cone solver -- This converts the equality constraints in to matrices
and bundles all the new variables in to a single vector optimization
variable. The CVX problem solved is</p>

<pre><code>minimize c'*x
subject to
  A*x == b
  x In K
</code></pre>

<p>where the cone <code>K</code> is entered literally (i.e., <code>norm([x(2),x(3)]) &lt;= x(1)</code>).</p></li>
<li><p><code>conelp</code> -- This performs the needed matrix stuffing and outputs the data
<code>A</code>, <code>b</code>, <code>G</code>, and <code>h</code> and calls the <code>conelp</code> solver in Matlab.</p></li>
<li><p><code>ECOS</code> -- This uses the same matrix stuffing and produces a call to
the <code>ECOS</code> solver in Matlab.</p></li>
</ul>

<h2>Directory structure</h2>

<p>This project is divided in to the following folders:</p>

<ul>
<li><code>src</code> -- Haskell source for the code generator</li>
<li><code>doc</code> -- Latex documentation for the code generator</li>
<li><code>matlab</code> -- Matlab test functions</li>
</ul>

<h2>Dependencies</h2>

<p>This project requires:</p>

<ul>
<li>Haskell -- The front end is written in <a href="http://www.haskell.org">Haskell</a> and
requires a Haskell installation to compile.</li>
<li><code>ECOS</code> -- The generated code calls the <code>ECOS</code> solver. Although the
code generator can be used to produce calls to <code>CVX</code>, this is less
interesting.</li>
<li>Matlab -- Matlab is used for testing the generated problems.</li>
</ul>

<p>Currently, Matlab is a required dependency since the code generator does not
actually emit source code; instead, the code generator will produce lines of
Matlab code and calls the <code>ECOS</code> solver. This is for testing purposes mostly
while we iron out the implementation.</p>

<p>Optional dependencies are:</p>

<ul>
<li><code>CVX</code> -- Calls to <code>CVX</code> are made to verify results. More information on
<code>CVX</code> can be found <a href="http://cvxr.com">here</a>.</li>
</ul>

<h2>Installation</h2>

<p>To install the ECOS front end, ensure that Haskell is installed and run the
following lines of code</p>

<pre><code>cd src
make
</code></pre>

<p>This will produce three binaries: <code>main</code>, <code>test</code>, and <code>efe</code>. At the
moment, only <code>efe</code> does anything. The other two binaries are in various
states of neglect. The <code>efe</code> binary takes a text file as input and
outputs the CVX representation of the problem (if the problem is DCP
compliant).</p>

<h2>EFE</h2>

<p>The <code>efe</code> binary takes as input a path to a text file that specifies an
optimization problem using the front end language. The target output can be
toggled with a command line option</p>

<ul>
<li><code>cvx</code> -- cvx output</li>
<li><code>cvxsocp</code> -- cvx socp output</li>
<li><code>conelp</code> -- conelp matlab output</li>
<li><code>ecos</code> -- ecos / paris matlab output.</li>
</ul>

<p>Running <code>efe</code> without any arguments will produce a list of options. It writes
the generated code to <code>stdout</code>.</p>

<h2>ECOS tester</h2>

<p>Under the <code>matlab</code> folder, a test driver called <code>ecos_tester</code> runs a suite of
problem tests. It compares the results to expected <code>CVX</code> results.</p>

<p>Some tests may fail because <code>ECOS</code> is not a high precision solver.</p>

<h2>Available atoms</h2>

<ul>
<li>infix atoms
<ul>
<li><code>+</code></li>
<li><code>-</code></li>
<li><code>*</code>, rhs <em>must</em> be a parameter</li>
</ul></li>
<li>prefix atoms
<ul>
<li><code>-</code>, unary minus / negate</li>
</ul></li>
<li>scalar atoms (map scalars to scalars)
<ul>
<li><code>pos(x)</code>, defined as <code>max([x; 0])</code></li>
<li><code>neg(x)</code>, defined as <code>max([-x; 0])</code></li>
<li><code>square(x)</code></li>
<li><code>inv_pos(x)</code></li>
<li><code>abs(x)</code></li>
<li><code>geo_mean(x,y)</code></li>
<li><code>sqrt(x)</code></li>
</ul></li>
<li>vector atoms (map vectors to scalars)
<ul>
<li><code>sum(x)</code></li>
<li><code>max(x)</code></li>
<li><code>min(x)</code></li>
<li><code>quad_over_lin(x,y)</code>, second argument must be scalar</li>
<li><code>norm(x)</code></li>
<li><code>norm2(x)</code>, equivalent to <code>norm(x)</code></li>
<li><code>norm1(x)</code></li>
<li><code>norm_inf(x)</code></li>
</ul></li>
</ul>

<h2>Syntax</h2>

<p>The input language follows a syntax similar to CVXGEN. If you are familiar
with imperative languages, then it shouldn't be too unfamiliar. Dimensions,
parameters, and variables (also called symbols) must be declared before use.
You cannot forward-declare these. However, you can declare them in whichever
order as long as you do not refer to undefined symbols: for instance, you
could write</p>

<pre><code>parameter b
dimension n = 10
variable x(n)
</code></pre>

<p>As a consequence, the problem declaration must appear last.</p>

<h3>Concatenation</h3>

<p>Only <em>vertical</em> concatenation is allowed. This is accomplished using Matlab
syntax:</p>

<pre><code>[x; y]
</code></pre>

<p>will concatenate two vector expressions vertically. It will not keep track of
individual properties. Instead, if a positive and negative (or convex and
concave) expression are concatenated, the result is a vector of unknown sign
(or curvature).</p>

<h2>Sample problem</h2>

<p>As an example, consider the following problem:</p>

<pre><code>dimension n = 5
dimension m = 10

parameter A(m,n)
parameter b(m)
parameter lambda positive
variable x(n)

minimize square(norm(A*x - b)) + lambda*norm1(x)
subject to
  x &gt;= 0
</code></pre>

<h2>Sample output</h2>

<p>Assuming the example text is saved to a file called <code>example.prob</code>, running <code>./efe --ecos example.prob</code> will produce:</p>

<pre><code>c_ = sparse(53,1);
c_(53) = 1;
b_ = sparse(41,1);
b_(2:2) = -0.5*ones(1, 1);
b_(3:3) = -0.5*ones(1, 1);
b_(24:33) = b;
A_ = sparse(41, 53);
A_(1:1, 29:29) = 1*ones(1, 1); A_(1:1, 30:30) = 1*speye(1, 1); A_(1:1, 53:53) = -1*speye(1, 1);
A_(2:2, 29:29) = 0.5*speye(1, 1); A_(2:2, 1:1) = -1*speye(1, 1);
A_(3:3, 29:29) = -0.5*speye(1, 1); A_(3:3, 2:2) = -1*speye(1, 1);
A_(4:13, 31:40) = 1*speye(10, 10); A_(4:13, 41:50) = -1*speye(10, 10); A_(4:13, 4:13) = -1*speye(10, 10);
A_(14:23, 19:23) = A; A_(14:23, 31:40) = -1*speye(10, 10);
A_(24:33, 41:50) = 1.0*speye(10, 10);
A_(34:34, 51:51) = lambda*speye(1, 1); A_(34:34, 30:30) = -1*speye(1, 1);
A_(35:35, 14:18) = 1*ones(1, 5); A_(35:35, 51:51) = -1*ones(1, 1);
A_(36:40, 19:23) = 1*speye(5, 5); A_(36:40, 24:28) = -1*speye(5, 5); A_(36:40, 52:52) = -1*ones(5, 1);
A_(41:41, 52:52) = 1.0*speye(1, 1);
G_ = sparse(29, 53);
G_(1:1:5, 24:28) = -speye(5, 5);
G_(6:2:15, 14:18) = -speye(5, 5);
G_(7:2:16, 19:23) = -speye(5, 5);
G_(16:1:16, 1:1) = -speye(1, 1);
G_(17:1:17, 2:2) = -speye(1, 1);
G_(18:1:18, 3:3) = -speye(1, 1);
G_(19:1:19, 3:3) = -speye(1, 1);
G_(20:1:29, 4:13) = -speye(10, 10);
h_ = zeros(29, 1);
dims.q = [2,2,2,2,2,3,11];
dims.l = 5;

[x_codegen, y_, info_] = ecos(full(c_), G_, h_, dims, A_, full(b_));

t1z0 = x_codegen(1:1);
t1z1 = x_codegen(2:2);
t2 = x_codegen(3:3);
t3 = x_codegen(4:13);
t7z0 = x_codegen(14:18);
x = x_codegen(19:23);
xGTt8 = x_codegen(24:28);
t1 = x_codegen(29:29);
t6 = x_codegen(30:30);
t4 = x_codegen(31:40);
t5 = x_codegen(41:50);
t7 = x_codegen(51:51);
t8 = x_codegen(52:52);
t0 = x_codegen(53:53);
ecos_optval = 1*info_.pcost;
</code></pre>
